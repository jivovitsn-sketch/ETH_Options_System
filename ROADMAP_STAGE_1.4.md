# üó∫Ô∏è STAGE 1.4: –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –í–°–ï–• –ò–ù–î–ò–ö–ê–¢–û–†–û–í + –ë–≠–ö–¢–ï–°–¢

## üìä –¶–ï–õ–¨
–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –í–°–ï –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã (—Ñ—å—é—á–µ—Ä—Å–Ω—ã–µ + –æ–ø—Ü–∏–æ–Ω–Ω—ã–µ) –≤ –µ–¥–∏–Ω—É—é —Å–∏—Å—Ç–µ–º—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞.

## üéØ –ü–†–ò–ù–¶–ò–ü–´ –†–ï–ê–õ–ò–ó–ê–¶–ò–ò
1. **MVP –ø–æ–¥—Ö–æ–¥** - –°–Ω–∞—á–∞–ª–∞ core –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã, –ø–æ—Ç–æ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
2. **–ü–æ—ç—Ç–∞–ø–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ** - –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≥—Ä—É–ø–ø—ã –æ—Ç–¥–µ–ª—å–Ω–æ
3. **–ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö** - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ
4. **–í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç—å** - –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤ –∏ –ª–æ–≥–æ–≤

---

## üéñÔ∏è –ü–†–ò–û–†–ò–¢–ï–¢–´ –ù–û–í–´–• –ò–ù–î–ò–ö–ê–¢–û–†–û–í

### üî¥ HIGH PRIORITY (—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–º–∏)
- [ ] **option_vwap_calculator.py** - –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, –≤—ã—Å–æ–∫–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å
- [ ] **PCR RSI** (–¥–æ—Ä–∞–±–æ—Ç–∫–∞ pcr_calculator.py) - –ö—Ä–∏—Ç–∏—á–µ–Ω –¥–ª—è —Ç–∞–π–º–∏–Ω–≥–∞
- [ ] **GEX RSI** (–¥–æ—Ä–∞–±–æ—Ç–∫–∞ gamma_exposure_calculator.py) - –í–∞–∂–µ–Ω –¥–ª—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏

### üü° MEDIUM PRIORITY (–ø–æ—Å–ª–µ HIGH)
- [ ] **oi_macd_calculator.py** - –°—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å, —Ö–æ—Ä–æ—à–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å
- [ ] **iv_macd_calculator.py** - –î–æ–ø–æ–ª–Ω—è–µ—Ç IV –∞–Ω–∞–ª–∏–∑

### üü¢ LOW PRIORITY (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
- [ ] **oi_velocity_rsi.py** - –ú–æ–∂–Ω–æ –æ—Ç–ª–æ–∂–∏—Ç—å, –¥—É–±–ª–∏—Ä—É–µ—Ç OI MACD

---

## ‚úÖ CHECKPOINT 1.4.1: –ò–ù–í–ï–ù–¢–ê–†–ò–ó–ê–¶–ò–Ø –ò–ù–î–ò–ö–ê–¢–û–†–û–í

### üü¢ –§–¨–Æ–ß–ï–†–°–ù–´–ï –ò–ù–î–ò–ö–ê–¢–û–†–´ (—á—Ç–æ —Å–æ–±–∏—Ä–∞–µ–º)
- [ ] Funding Rate (funding_rate_monitor.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] Liquidations (liquidations_monitor.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] Futures OI (futures_data_monitor.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] –°–ø–æ—Ç —Ü–µ–Ω—ã (futures_data_monitor.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢

### üîµ –û–ü–¶–ò–û–ù–ù–´–ï –ò–ù–î–ò–ö–ê–¢–û–†–´ (—á—Ç–æ —Å–æ–±–∏—Ä–∞–µ–º)
- [ ] PCR - Put/Call Ratio (pcr_calculator.py) ‚úÖ –°–û–ó–î–ê–ù
- [ ] OI - Open Interest (unlimited_oi_monitor.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] Max Pain (max_pain_calculator.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] GEX - Gamma Exposure (gamma_exposure_calculator.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢
- [ ] Vanna Exposure (vanna_calculator.py) ‚úÖ –°–û–ó–î–ê–ù
- [ ] IV Rank (iv_rank_calculator.py) ‚úÖ –°–û–ó–î–ê–ù (–Ω—É–∂–Ω—ã –¥–∞–Ω–Ω—ã–µ volatility)
- [ ] Volatility & Greeks (volatility_greeks_analyzer.py) ‚úÖ –†–ê–ë–û–¢–ê–ï–¢

### üü° –ù–û–í–´–ï –ò–ù–î–ò–ö–ê–¢–û–†–´ (–Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å)
- [ ] üî¥ VWAP –¥–ª—è –æ–ø—Ü–∏–æ–Ω–æ–≤ (option_vwap_calculator.py)
- [ ] üî¥ RSI –æ—Ç PCR (–≤—Å—Ç—Ä–æ–∏—Ç—å –≤ pcr_calculator.py)
- [ ] üî¥ RSI –æ—Ç GEX (–≤—Å—Ç—Ä–æ–∏—Ç—å –≤ gamma_exposure_calculator.py)
- [ ] üü° MACD –æ—Ç OI (oi_macd_calculator.py)
- [ ] üü° MACD –æ—Ç IV (iv_macd_calculator.py)
- [ ] üü¢ RSI –æ—Ç OI Velocity (oi_velocity_rsi.py)

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –ò–Ω–≤–µ–Ω—Ç–∞—Ä–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞
‚úÖ –í—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞—é—Ç JSON —Ñ–∞–π–ª—ã
‚úÖ –û–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –¥–ª—è –Ω–æ–≤—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç —á–µ—Ä–µ–∑ system_manager

---

## ‚úÖ CHECKPOINT 1.4.2: –°–û–ó–î–ê–ù–ò–ï –ò–ù–¢–ï–ì–†–ê–¢–û–†–ê –î–ê–ù–ù–´–•

### üì¶ DataIntegrator Class
```python
# data_integrator.py
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class DataIntegrator:
    """–û–±—ä–µ–¥–∏–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–ª—è –∞–∫—Ç–∏–≤–∞"""
    
    def __init__(self):
        self.data_sources = {
            'futures': get_futures_data,
            'funding': get_funding_rate,
            'liquidations': get_liquidations,
            'pcr': get_pcr_data,
            'oi': get_oi_data,
            'max_pain': get_max_pain,
            'gex': get_gamma_exposure,
            'vanna': get_vanna_data,
            'iv_rank': get_iv_rank_data,
            'option_vwap': get_option_vwap,
            'pcr_rsi': get_pcr_rsi,
            'oi_macd': get_oi_macd,
            'iv_macd': get_iv_macd
        }
    
    def get_all_data(self, asset: str) -> Dict[str, Any]:
        """–°–æ–±—Ä–∞—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–∫—Ç–∏–≤–∞"""
        try:
            data = {
                'asset': asset,
                'timestamp': datetime.now(),
                'spot_price': None,
                'available_sources': []
            }
            
            # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
            for source_name, source_func in self.data_sources.items():
                try:
                    result = source_func(asset)
                    data[source_name] = result
                    
                    if result is not None:
                        data['available_sources'].append(source_name)
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º spot_price –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
                    if data['spot_price'] is None and result:
                        if isinstance(result, dict) and 'spot_price' in result:
                            data['spot_price'] = result['spot_price']
                        elif source_name == 'futures' and result.get('price'):
                            data['spot_price'] = result['price']
                
                except Exception as e:
                    logger.warning(f"Failed to get {source_name} for {asset}: {e}")
                    data[source_name] = None
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
            data['quality'] = self.get_data_quality_report(data)
            
            return data
            
        except Exception as e:
            logger.error(f"Failed to integrate data for {asset}: {e}")
            return self._get_fallback_data(asset)
    
    def _get_fallback_data(self, asset: str) -> Dict[str, Any]:
        """–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–µ"""
        logger.warning(f"Using fallback data for {asset}")
        
        # –•–æ—Ç—è –±—ã —Å–ø–æ—Ç —Ü–µ–Ω–∞ –∏ timestamp
        try:
            futures = get_futures_data(asset)
            spot_price = futures.get('price') if futures else None
        except:
            spot_price = None
        
        return {
            'asset': asset,
            'timestamp': datetime.now(),
            'spot_price': spot_price,
            'available_sources': [],
            'quality': {'status': 'FALLBACK'},
            'error': 'Critical error in data integration'
        }
    
    def get_data_quality_report(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """–û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        total_sources = len(self.data_sources)
        available = len(data.get('available_sources', []))
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–µ–∂–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
        max_age_minutes = 0
        if 'timestamp' in data:
            for source in data.get('available_sources', []):
                if isinstance(data.get(source), dict) and 'timestamp' in data[source]:
                    try:
                        source_time = datetime.fromisoformat(data[source]['timestamp'])
                        age = (data['timestamp'] - source_time).total_seconds() / 60
                        max_age_minutes = max(max_age_minutes, age)
                    except:
                        pass
        
        completeness = available / total_sources
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        if completeness >= 0.8 and max_age_minutes < 30:
            status = 'EXCELLENT'
        elif completeness >= 0.6 and max_age_minutes < 60:
            status = 'GOOD'
        elif completeness >= 0.4:
            status = 'ACCEPTABLE'
        else:
            status = 'POOR'
        
        return {
            'status': status,
            'available_sources': available,
            'total_sources': total_sources,
            'completeness': completeness,
            'max_age_minutes': max_age_minutes,
            'missing_sources': [s for s in self.data_sources.keys() 
                               if s not in data.get('available_sources', [])]
        }
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ DataIntegrator –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ª—é–±–æ–≥–æ –∞–∫—Ç–∏–≤–∞
‚úÖ Graceful degradation - —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–∞–∂–µ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —á–∞—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
‚úÖ Data quality report –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç completeness –∏ freshness
‚úÖ –õ–æ–≥–∏—Ä—É–µ—Ç –∫–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
‚úÖ Fallback –º–µ—Ö–∞–Ω–∏–∑–º –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö

---

## ‚úÖ CHECKPOINT 1.4.3: –°–û–ó–î–ê–ù–ò–ï SIGNAL ANALYZER –° –ü–ê–†–ê–ú–ï–¢–†–ê–ú–ò

### üéØ SignalAnalyzer Class
```python
# signal_analyzer.py
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

class SignalAnalyzer:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–∏–≥–Ω–∞–ª —Å –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        config = {
            # –í–ï–°–ê –ì–†–£–ü–ü (–±—É–¥—É—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ –±—ç–∫—Ç–µ—Å—Ç–µ)
            'futures_weight': 0.35,
            'options_weight': 0.40,
            'timing_weight': 0.25,
            
            # –í–ï–°–ê –ò–ù–î–ò–ö–ê–¢–û–†–û–í –í–ù–£–¢–†–ò –ì–†–£–ü–ü
            'futures': {
                'funding_weight': 0.40,
                'liquidations_weight': 0.60
            },
            'options': {
                'oi_weight': 0.15,
                'max_pain_weight': 0.15,
                'gex_weight': 0.15,
                'pcr_weight': 0.15,
                'vanna_weight': 0.20,
                'iv_rank_weight': 0.20
            },
            'timing': {
                'option_vwap_weight': 0.20,
                'pcr_rsi_weight': 0.25,
                'oi_macd_weight': 0.25,
                'iv_macd_weight': 0.30
            },
            
            # –ü–û–†–û–ì–ò
            'min_confidence': 0.75,
            'strong_threshold': 0.85,
            
            # –§–ò–õ–¨–¢–†–´
            'require_futures_confirm': True,
            'require_options_confirm': True,
            'min_data_sources': 5,
            'min_data_quality': 'ACCEPTABLE'
        }
        """
        self.config = self._validate_config(config)
    
    def _validate_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –≤–µ—Å–∞ –≥—Ä—É–ø–ø –≤ —Å—É–º–º–µ –¥–∞—é—Ç 1.0
        total_weights = (
            config.get('futures_weight', 0) +
            config.get('options_weight', 0) +
            config.get('timing_weight', 0)
        )
        
        if abs(total_weights - 1.0) > 0.01:
            raise ValueError(f"Group weights must sum to 1.0, got {total_weights}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Å–æ–≤ –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø
        for group in ['futures', 'options', 'timing']:
            if group in config:
                group_total = sum(config[group].values())
                if abs(group_total - 1.0) > 0.01:
                    raise ValueError(f"{group} weights must sum to 1.0, got {group_total}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä–æ–≥–æ–≤
        min_conf = config.get('min_confidence', 0.75)
        strong = config.get('strong_threshold', 0.85)
        
        if not (0 < min_conf < 1):
            raise ValueError(f"min_confidence must be between 0 and 1, got {min_conf}")
        
        if not (min_conf < strong < 1):
            raise ValueError(f"strong_threshold must be > min_confidence and < 1")
        
        logger.info("‚úÖ Config validation passed")
        return config
    
    def analyze(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """–ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞"""
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
        if not self._check_data_quality(data):
            logger.warning(f"Data quality too low for {data.get('asset')}")
            return None
        
        # –ê–Ω–∞–ª–∏–∑ –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã
        futures_signal = self._analyze_futures(data)
        options_signal = self._analyze_options(data)
        timing_signal = self._analyze_timing(data)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        if not self._pass_filters(futures_signal, options_signal, timing_signal):
            logger.info(f"Signal filters not passed for {data.get('asset')}")
            return None
        
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è
        total_confidence = (
            futures_signal['confidence'] * self.config['futures_weight'] +
            options_signal['confidence'] * self.config['options_weight'] +
            timing_signal['confidence'] * self.config['timing_weight']
        )
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        signal_type = self._determine_signal_type(
            futures_signal,
            options_signal,
            timing_signal
        )
        
        # –°–±–æ—Ä reasoning
        reasoning = self._build_reasoning(
            futures_signal,
            options_signal,
            timing_signal
        )
        
        return {
            'signal_type': signal_type,
            'confidence': total_confidence,
            'strength': self._classify_strength(total_confidence),
            'components': {
                'futures': futures_signal,
                'options': options_signal,
                'timing': timing_signal
            },
            'reasoning': reasoning,
            'config_version': self._get_config_hash(),
            'data_quality': data.get('quality')
        }
    
    def _check_data_quality(self, data: Dict[str, Any]) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö"""
        quality = data.get('quality', {})
        
        # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
        min_sources = self.config.get('min_data_sources', 5)
        if quality.get('available_sources', 0) < min_sources:
            return False
        
        # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
        required_quality = self.config.get('min_data_quality', 'ACCEPTABLE')
        quality_levels = ['POOR', 'ACCEPTABLE', 'GOOD', 'EXCELLENT']
        
        actual = quality.get('status', 'POOR')
        if quality_levels.index(actual) < quality_levels.index(required_quality):
            return False
        
        return True
    
    def _analyze_futures(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """–ê–Ω–∞–ª–∏–∑ —Ñ—å—é—á–µ—Ä—Å–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        confidence = 0.5
        signal = 'NEUTRAL'
        reasons = []
        
        weights = self.config.get('futures', {})
        
        # Funding Rate
        funding = data.get('funding')
        if funding and funding.get('funding_rate'):
            fr = funding['funding_rate']
            fr_weight = weights.get('funding_weight', 0.4)
            
            if fr > 0.01:  # –õ–æ–Ω–≥–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω—ã
                confidence -= 0.15 * fr_weight
                signal = 'BEARISH'
                reasons.append(f"High funding {fr*100:.3f}% (longs overcrowded)")
            elif fr < -0.01:  # –®–æ—Ä—Ç—ã –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω—ã
                confidence += 0.15 * fr_weight
                signal = 'BULLISH'
                reasons.append(f"Negative funding {fr*100:.3f}% (shorts overcrowded)")
        
        # Liquidations
        liq = data.get('liquidations')
        if liq:
            ratio = liq.get('ratio', 1.0)
            liq_weight = weights.get('liquidations_weight', 0.6)
            
            if ratio > 2.0:  # –ë–æ–ª—å—à–µ –ª–æ–Ω–≥–æ–≤ –ª–∏–∫–≤–∏–¥–∏—Ä–æ–≤–∞–Ω–æ
                confidence -= 0.20 * liq_weight
                if signal == 'NEUTRAL':
                    signal = 'BEARISH'
                reasons.append(f"Liquidation ratio {ratio:.2f} (longs squeezed)")
            elif ratio < 0.5:  # –ë–æ–ª—å—à–µ —à–æ—Ä—Ç–æ–≤ –ª–∏–∫–≤–∏–¥–∏—Ä–æ–≤–∞–Ω–æ
                confidence += 0.20 * liq_weight
                if signal == 'NEUTRAL':
                    signal = 'BULLISH'
                reasons.append(f"Liquidation ratio {ratio:.2f} (shorts squeezed)")
        
        return {
            'signal': signal,
            'confidence': max(min(confidence, 1.0), 0.0),
            'reasoning': reasons,
            'data_used': ['funding', 'liquidations']
        }
    
    def _analyze_options(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """–ê–Ω–∞–ª–∏–∑ –æ–ø—Ü–∏–æ–Ω–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        confidence = 0.5
        signal = 'NEUTRAL'
        reasons = []
        
        weights = self.config.get('options', {})
        
        # OI Analysis
        oi = data.get('oi')
        if oi:
            oi_change = oi.get('change_pct', 0)
            oi_weight = weights.get('oi_weight', 0.15)
            
            if oi_change > 10:
                confidence += 0.12 * oi_weight
                reasons.append(f"OI growing {oi_change:.1f}%")
            elif oi_change < -10:
                confidence -= 0.12 * oi_weight
                reasons.append(f"OI declining {oi_change:.1f}%")
        
        # Max Pain
        max_pain = data.get('max_pain')
        if max_pain:
            distance_pct = max_pain.get('distance_pct', 0)
            mp_weight = weights.get('max_pain_weight', 0.15)
            
            if abs(distance_pct) > 3:
                confidence += 0.10 * mp_weight
                if distance_pct > 0:
                    reasons.append(f"Above Max Pain by {distance_pct:.1f}%")
                else:
                    reasons.append(f"Below Max Pain by {abs(distance_pct):.1f}%")
        
        # GEX
        gex = data.get('gex')
        if gex:
            total_gex = gex.get('total_gex', 0)
            gex_weight = weights.get('gex_weight', 0.15)
            
            if total_gex < 0:
                confidence += 0.10 * gex_weight
                signal = 'BULLISH' if signal == 'NEUTRAL' else signal
                reasons.append("Negative GEX (volatile support)")
        
        # PCR
        pcr = data.get('pcr')
        if pcr:
            pcr_oi = pcr.get('pcr_oi', 1.0)
            pcr_weight = weights.get('pcr_weight', 0.15)
            
            if pcr_oi > 1.5:
                confidence += 0.08 * pcr_weight
                reasons.append(f"High PCR {pcr_oi:.2f} (protective puts)")
            elif pcr_oi < 0.7:
                confidence -= 0.08 * pcr_weight
                reasons.append(f"Low PCR {pcr_oi:.2f} (speculative calls)")
        
        # Vanna
        vanna = data.get('vanna')
        if vanna:
            total_vanna = vanna.get('total_vanna', 0)
            vanna_weight = weights.get('vanna_weight', 0.20)
            
            if abs(total_vanna) > 500:
                if total_vanna > 0:
                    confidence += 0.12 * vanna_weight
                    signal = 'BULLISH' if signal == 'NEUTRAL' else signal
                else:
                    confidence -= 0.12 * vanna_weight
                    signal = 'BEARISH' if signal == 'NEUTRAL' else signal
                reasons.append(f"Strong Vanna {total_vanna:.0f}")
        
        # IV Rank
        iv_rank = data.get('iv_rank')
        if iv_rank:
            rank = iv_rank.get('iv_rank_52w', 50)
            iv_weight = weights.get('iv_rank_weight', 0.20)
            
            if rank > 75:
                confidence += 0.06 * iv_weight
                reasons.append(f"High IV Rank {rank:.0f}%")
            elif rank < 25:
                confidence += 0.06 * iv_weight
                reasons.append(f"Low IV Rank {rank:.0f}%")
        
        return {
            'signal': signal,
            'confidence': max(min(confidence, 1.0), 0.0),
            'reasoning': reasons,
            'data_used': ['oi', 'max_pain', 'gex', 'pcr', 'vanna', 'iv_rank']
        }
    
    def _analyze_timing(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """–ê–Ω–∞–ª–∏–∑ —Ç–∞–π–º–∏–Ω–≥–æ–≤—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        confidence = 0.5
        signal = 'NEUTRAL'
        reasons = []
        
        weights = self.config.get('timing', {})
        
        # Option VWAP
        vwap = data.get('option_vwap')
        if vwap:
            vwap_weight = weights.get('option_vwap_weight', 0.20)
            # –õ–æ–≥–∏–∫–∞ VWAP
            reasons.append("Option VWAP analyzed")
        
        # PCR RSI
        pcr_rsi = data.get('pcr_rsi')
        if pcr_rsi:
            rsi_val = pcr_rsi.get('rsi', 50)
            rsi_weight = weights.get('pcr_rsi_weight', 0.25)
            
            if rsi_val > 70:
                confidence += 0.10 * rsi_weight
                signal = 'BULLISH'
                reasons.append(f"PCR RSI {rsi_val:.0f} (extreme fear)")
            elif rsi_val < 30:
                confidence -= 0.10 * rsi_weight
                signal = 'BEARISH'
                reasons.append(f"PCR RSI {rsi_val:.0f} (extreme greed)")
        
        # OI MACD
        oi_macd = data.get('oi_macd')
        if oi_macd:
            macd_weight = weights.get('oi_macd_weight', 0.25)
            trend = oi_macd.get('trend', 'NEUTRAL')
            
            if trend == 'BULLISH':
                confidence += 0.08 * macd_weight
                reasons.append("OI MACD bullish crossover")
            elif trend == 'BEARISH':
                confidence -= 0.08 * macd_weight
                reasons.append("OI MACD bearish crossover")
        
        # IV MACD
        iv_macd = data.get('iv_macd')
        if iv_macd:
            iv_weight = weights.get('iv_macd_weight', 0.30)
            trend = iv_macd.get('trend', 'STABLE')
            
            if trend == 'EXPANDING':
                confidence += 0.05 * iv_weight
                reasons.append("IV expanding (uncertainty rising)")
        
        return {
            'signal': signal,
            'confidence': max(min(confidence, 1.0), 0.0),
            'reasoning': reasons,
            'data_used': ['option_vwap', 'pcr_rsi', 'oi_macd', 'iv_macd']
        }
    
    def _pass_filters(self, futures_sig, options_sig, timing_sig) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —Å–∏–≥–Ω–∞–ª–∞"""
        
        # –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç —Ñ—å—é—á–µ—Ä—Å–æ–≤
        if self.config.get('require_futures_confirm', True):
            if futures_sig['confidence'] < 0.6:
                return False
        
        # –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç –æ–ø—Ü–∏–æ–Ω–æ–≤
        if self.config.get('require_options_confirm', True):
            if options_sig['confidence'] < 0.6:
                return False
        
        return True
    
    def _determine_signal_type(self, futures_sig, options_sig, timing_sig) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞"""
        signals = [
            futures_sig['signal'],
            options_sig['signal'],
            timing_sig['signal']
        ]
        
        bullish_count = signals.count('BULLISH')
        bearish_count = signals.count('BEARISH')
        
        if bullish_count >= 2:
            return 'BULLISH'
        elif bearish_count >= 2:
            return 'BEARISH'
        else:
            return 'NEUTRAL'
    
    def _build_reasoning(self, futures_sig, options_sig, timing_sig) -> List[str]:
        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–π –∏–∑ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
        all_reasons = []
        
        all_reasons.extend(futures_sig['reasoning'])
        all_reasons.extend(options_sig['reasoning'])
        all_reasons.extend(timing_sig['reasoning'])
        
        # –¢–æ–ø-8 –ø—Ä–∏—á–∏–Ω
        return all_reasons[:8]
    
    def _classify_strength(self, confidence: float) -> str:
        """–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Å–∏–ª—ã —Å–∏–≥–Ω–∞–ª–∞"""
        strong = self.config.get('strong_threshold', 0.85)
        
        if confidence >= strong:
            return 'STRONG'
        elif confidence >= self.config.get('min_confidence', 0.75):
            return 'MODERATE'
        else:
            return 'WEAK'
    
    def _get_config_hash(self) -> str:
        """–•—ç—à –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"""
        import hashlib
        import json
        
        config_str = json.dumps(self.config, sort_keys=True)
        return hashlib.md5(config_str.encode()).hexdigest()[:8]
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ SignalAnalyzer —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º –≤–∞–ª–∏–¥–Ω—ã–º config
‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫–∏
‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–∏–≥–Ω–∞–ª —Å confidence, strength –∏ reasoning
‚úÖ Graceful degradation –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –¥–∞–Ω–Ω—ã—Ö
‚úÖ –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ hash
‚úÖ –õ–æ–≥–∏—Ä—É–µ—Ç –∫–∞–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å

---

## ‚úÖ CHECKPOINT 1.4.4: –ü–ê–†–ê–ú–ï–¢–†–´ –î–õ–Ø –ë–≠–ö–¢–ï–°–¢–ê

### üìã –§–∞–π–ª backtest_params.py
```python
# backtest_params.py
"""
–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤ –±—ç–∫—Ç–µ—Å—Ç–µ
"""

BACKTEST_PARAMETERS = {
    # ===== –í–ï–°–ê –ì–†–£–ü–ü =====
    'futures_weight': {
        'min': 0.20,
        'max': 0.50,
        'step': 0.05,
        'default': 0.35,
        'description': '–í–µ—Å —Ñ—å—é—á–µ—Ä—Å–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤'
    },
    'options_weight': {
        'min': 0.30,
        'max': 0.60,
        'step': 0.05,
        'default': 0.40,
        'description': '–í–µ—Å –æ–ø—Ü–∏–æ–Ω–Ω—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤'
    },
    'timing_weight': {
        'min': 0.10,
        'max': 0.40,
        'step': 0.05,
        'default': 0.25,
        'description': '–í–µ—Å —Ç–∞–π–º–∏–Ω–≥–æ–≤—ã—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤'
    },
    
    # ===== –í–ï–°–ê –ò–ù–î–ò–ö–ê–¢–û–†–û–í: –§–¨–Æ–ß–ï–†–°–ù–´–ï =====
    'funding_weight': {
        'min': 0.20,
        'max': 0.80,
        'step': 0.10,
        'default': 0.40,
        'group': 'futures'
    },
    'liquidations_weight': {
        'min': 0.20,
        'max': 0.80,
        'step': 0.10,
        'default': 0.60,
        'group': 'futures'
    },
    
    # ===== –í–ï–°–ê –ò–ù–î–ò–ö–ê–¢–û–†–û–í: –û–ü–¶–ò–û–ù–ù–´–ï =====
    'oi_weight': {
        'min': 0.05,
        'max': 0.30,
        'step': 0.05,
        'default': 0.15,
        'group': 'options'
    },
    'max_pain_weight': {
        'min': 0.05,
        'max': 0.30,
        'step': 0.05,
        'default': 0.15,
        'group': 'options'
    },
    'gex_weight': {
        'min': 0.05,
        'max': 0.30,
        'step': 0.05,
        'default': 0.15,
        'group': 'options'
    },
    'pcr_weight': {
        'min': 0.05,
        'max': 0.30,
        'step': 0.05,
        'default': 0.15,
        'group': 'options'
    },
    'vanna_weight': {
        'min': 0.10,
        'max': 0.40,
        'step': 0.05,
        'default': 0.20,
        'group': 'options'
    },
    'iv_rank_weight': {
        'min': 0.10,
        'max': 0.40,
        'step': 0.05,
        'default': 0.20,
        'group': 'options'
    },
    
    # ===== –í–ï–°–ê –ò–ù–î–ò–ö–ê–¢–û–†–û–í: –¢–ê–ô–ú–ò–ù–ì =====
    'option_vwap_weight': {
        'min': 0.10,
        'max': 0.40,
        'step': 0.05,
        'default': 0.20,
        'group': 'timing'
    },
    'pcr_rsi_weight': {
        'min': 0.15,
        'max': 0.45,
        'step': 0.05,
        'default': 0.25,
        'group': 'timing'
    },
    'oi_macd_weight': {
        'min': 0.15,
        'max': 0.45,
        'step': 0.05,
        'default': 0.25,
        'group': 'timing'
    },
    'iv_macd_weight': {
        'min': 0.20,
        'max': 0.50,
        'step': 0.05,
        'default': 0.30,
        'group': 'timing'
    },
    
    # ===== –ü–û–†–û–ì–ò =====
    'min_confidence': {
        'min': 0.60,
        'max': 0.85,
        'step': 0.05,
        'default': 0.75,
        'description': '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞'
    },
    'strong_threshold': {
        'min': 0.75,
        'max': 0.95,
        'step': 0.05,
        'default': 0.85,
        'description': '–ü–æ—Ä–æ–≥ –¥–ª—è STRONG —Å–∏–≥–Ω–∞–ª–∞'
    },
    
    # ===== –§–ò–õ–¨–¢–†–´ =====
    'min_data_sources': {
        'min': 3,
        'max': 8,
        'step': 1,
        'default': 5,
        'description': '–ú–∏–Ω–∏–º—É–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞'
    }
}

# –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π
def count_combinations():
    """–ü–æ–¥—Å—á–µ—Ç –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"""
    total = 1
    for param, settings in BACKTEST_PARAMETERS.items():
        if 'min' in settings and 'max' in settings and 'step' in settings:
            count = int((settings['max'] - settings['min']) / settings['step']) + 1
            total *= count
    return total

def get_default_config():
    """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é"""
    config = {
        'futures_weight': 0.35,
        'options_weight': 0.40,
        'timing_weight': 0.25,
        'futures': {},
        'options': {},
        'timing': {},
        'min_confidence': 0.75,
        'strong_threshold': 0.85,
        'min_data_sources': 5,
        'require_futures_confirm': True,
        'require_options_confirm': True,
        'min_data_quality': 'ACCEPTABLE'
    }
    
    # –ó–∞–ø–æ–ª–Ω—è–µ–º –≤–µ—Å–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    for param, settings in BACKTEST_PARAMETERS.items():
        if 'group' in settings:
            group = settings['group']
            config[group][param] = settings['default']
    
    return config

def generate_random_config():
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–π –≤–∞–ª–∏–¥–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    import random
    
    config = get_default_config()
    
    for param, settings in BACKTEST_PARAMETERS.items():
        if 'min' in settings and 'max' in settings and 'step' in settings:
            min_val = settings['min']
            max_val = settings['max']
            step = settings['step']
            
            # –°–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–∞
            steps_count = int((max_val - min_val) / step)
            random_steps = random.randint(0, steps_count)
            value = min_val + random_steps * step
            
            if 'group' in settings:
                group = settings['group']
                config[group][param] = value
            else:
                config[param] = value
    
    return config

# –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
if __name__ == '__main__':
    print(f"Total parameter combinations: {count_combinations():,}")
    print(f"Note: This number is too large for exhaustive search.")
    print(f"ML optimization (Bayesian/Genetic) is required.")
    print()
    print("Default config:")
    import json
    print(json.dumps(get_default_config(), indent=2))
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–ª—è –≤—Å–µ—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Å –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º–∏
‚úÖ –î–∏–∞–ø–∞–∑–æ–Ω—ã –∑–Ω–∞—á–µ–Ω–∏–π —Ä–∞–∑—É–º–Ω—ã–µ –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º—ã–µ
‚úÖ –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è default –∏ random –∫–æ–Ω—Ñ–∏–≥–æ–≤ —Ä–∞–±–æ—Ç–∞—é—Ç
‚úÖ –ú–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å/—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å config –≤ JSON
‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã

---

## ‚úÖ CHECKPOINT 1.4.5: –û–ë–ù–û–í–õ–ï–ù–ò–ï advanced_signals_generator.py

### üîÑ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ SignalAnalyzer
```python
# –í advanced_signals_generator.py

from data_integrator import DataIntegrator
from signal_analyzer import SignalAnalyzer
from backtest_params import get_default_config
import json
import os

class SignalGenerator:
    def __init__(self, config_file='signal_config.json'):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞"""
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥ (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º default)
        if os.path.exists(config_file):
            logger.info(f"Loading config from {config_file}")
            with open(config_file, 'r') as f:
                config = json.load(f)
        else:
            logger.info("Using default config")
            config = get_default_config()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.data_integrator = DataIntegrator()
        self.signal_analyzer = SignalAnalyzer(config)
        
        # –î–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏
        self.signal_history_logger = SignalHistoryLogger()
        
        logger.info(f"SignalGenerator initialized with config hash: {self.signal_analyzer._get_config_hash()}")
    
    def generate_signal(self, asset: str) -> Optional[Dict[str, Any]]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è –∞–∫—Ç–∏–≤–∞"""
        
        try:
            # 1. –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
            logger.info(f"üîç Analyzing {asset}...")
            data = self.data_integrator.get_all_data(asset)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
            quality = data.get('quality', {})
            logger.info(f"üìä Data quality: {quality.get('status')} ({quality.get('completeness', 0)*100:.0f}%)")
            
            # 2. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å
            signal = self.signal_analyzer.analyze(data)
            
            if not signal:
                logger.info(f"‚û°Ô∏è {asset}: No signal (filters not passed)")
                return None
            
            # 3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é confidence
            if signal['confidence'] < self.signal_analyzer.config['min_confidence']:
                logger.info(f"üìä {asset}: Low confidence {signal['confidence']*100:.0f}%")
                return None
            
            # 4. –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–ø—Ü–∏–æ–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            spot_price = data.get('spot_price')
            if not spot_price:
                logger.warning(f"‚ö†Ô∏è {asset}: No spot price available")
                return None
            
            strategies = generate_option_strategies(
                asset,
                signal['signal_type'],
                spot_price,
                signal['confidence']
            )
            
            result = {
                'asset': asset,
                'signal': signal,
                'strategies': strategies,
                'data_snapshot': data,
                'timestamp': datetime.now()
            }
            
            # 5. –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞
            self.signal_history_logger.log_signal(result)
            
            logger.info(f"‚úÖ {asset}: {signal['signal_type']} {signal['confidence']*100:.0f}% ({signal['strength']})")
            logger.info(f"   Reasons: {', '.join(signal['reasoning'][:3])}")
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Error generating signal for {asset}: {e}")
            return None
    
    def run(self):
        """–ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–æ–≤"""
        logger.info("=" * 80)
        logger.info(f"üöÄ SIGNAL GENERATION: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"üìù Config: {self.signal_analyzer._get_config_hash()}")
        logger.info("=" * 80)
        
        assets = ['BTC', 'ETH', 'SOL', 'XRP', 'DOGE', 'MNT']
        sent_count = 0
        skipped_count = 0
        
        for asset in assets:
            result = self.generate_signal(asset)
            
            if result:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å
                if self.should_send_signal(asset, result):
                    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    message = format_option_signal_message(
                        asset,
                        result['signal']['signal_type'],
                        result['signal']['confidence'],
                        result['data_snapshot']['spot_price'],
                        result['strategies']
                    )
                    
                    self.send_telegram_message(message, is_vip=True)
                    
                    # FREE –∫–∞–Ω–∞–ª
                    self.send_to_free_channel(
                        asset,
                        result['signal']['signal_type'],
                        result['signal']['confidence'],
                        result['data_snapshot']['spot_price']
                    )
                    
                    sent_count += 1
                else:
                    logger.info(f"‚è≠Ô∏è {asset}: Already sent recently")
                    skipped_count += 1
            else:
                skipped_count += 1
        
        logger.info("=" * 80)
        logger.info(f"‚úÖ Generation complete. Sent: {sent_count}, Skipped: {skipped_count}")
        logger.info("=" * 80)
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç DataIntegrator
‚úÖ –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç SignalAnalyzer —Å –∫–æ–Ω—Ñ–∏–≥–æ–º
‚úÖ –ú–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å signal_config.json –∏ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –º–µ–Ω—è–µ—Ç—Å—è
‚úÖ –õ–æ–≥–∏—Ä—É–µ—Ç config hash –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–µ—Ä—Å–∏–π
‚úÖ –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ª–æ–≥–∏–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏

---

## ‚úÖ CHECKPOINT 1.4.6: –°–û–ó–î–ê–ù–ò–ï –ù–ï–î–û–°–¢–ê–Æ–©–ò–• –ò–ù–î–ò–ö–ê–¢–û–†–û–í

### üÜï –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è (–≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞):

#### üî¥ HIGH PRIORITY

##### 1. option_vwap_calculator.py
```python
# –†–∞—Å—á–µ—Ç VWAP –¥–ª—è –æ–ø—Ü–∏–æ–Ω–Ω—ã—Ö —Ü–µ–Ω –∏ IV
# –í—Ö–æ–¥—ã: unlimited_oi.db
# –í—ã—Ö–æ–¥: data/option_vwap/{ASSET}_vwap_YYYYMMDD_HHMMSS.json
# –ü–æ–ª—è: price_vwap, iv_vwap, premium_vwap
```

##### 2. –û–±–Ω–æ–≤–∏—Ç—å pcr_calculator.py
```python
# –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—á–µ—Ç PCR RSI
# –ù–æ–≤—ã–µ –ø–æ–ª—è –≤ JSON: pcr_rsi, rsi_interpretation
```

##### 3. –û–±–Ω–æ–≤–∏—Ç—å gamma_exposure_calculator.py
```python
# –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—á–µ—Ç GEX RSI
# –ù–æ–≤—ã–µ –ø–æ–ª—è –≤ JSON: gex_rsi, gex_trend
```

#### üü° MEDIUM PRIORITY

##### 4. oi_macd_calculator.py
```python
# MACD –æ—Ç –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ OI
# –í—Ö–æ–¥—ã: unlimited_oi.db (–∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ OI)
# –í—ã—Ö–æ–¥: data/oi_macd/{ASSET}_macd_YYYYMMDD_HHMMSS.json
# –ü–æ–ª—è: macd, signal_line, histogram, trend
```

##### 5. iv_macd_calculator.py
```python
# MACD –æ—Ç IV surface
# –í—Ö–æ–¥—ã: data/volatility/*.json (–∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ IV)
# –í—ã—Ö–æ–¥: data/iv_macd/{ASSET}_iv_macd_YYYYMMDD_HHMMSS.json
# –ü–æ–ª—è: macd, signal_line, histogram, trend
```

#### üü¢ LOW PRIORITY

##### 6. oi_velocity_rsi.py
```python
# RSI –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è OI (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
# –ú–æ–∂–µ—Ç –±—ã—Ç—å –æ–±—ä–µ–¥–∏–Ω–µ–Ω —Å oi_macd_calculator.py
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –í—Å–µ HIGH PRIORITY –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã
‚úÖ MEDIUM PRIORITY —Å–æ–∑–¥–∞–Ω—ã –∏–ª–∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω—ã
‚úÖ –í—Å–µ —Å–æ–∑–¥–∞—é—Ç JSON –≤—ã—Ö–æ–¥—ã –≤ –Ω—É–∂–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö
‚úÖ –î–æ–±–∞–≤–ª–µ–Ω—ã –≤ system_manager analytics
‚úÖ –¢–µ—Å—Ç—ã –ø—Ä–æ–≤–µ—Ä—è—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ä–∞—Å—á–µ—Ç–æ–≤

---

## ‚úÖ CHECKPOINT 1.4.7: –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï

### üß™ –¢–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞–Ω:

#### 1. Unit —Ç–µ—Å—Ç—ã –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
```bash
# tests/test_indicators.py
pytest tests/test_indicators.py -v
```

#### 2. Integration —Ç–µ—Å—Ç—ã
```bash
# tests/test_data_integrator.py
pytest tests/test_data_integrator.py -v

# tests/test_signal_analyzer.py  
pytest tests/test_signal_analyzer.py -v
```

#### 3. End-to-end —Ç–µ—Å—Ç
```bash
# tests/test_e2e_signal_generation.py
pytest tests/test_e2e_signal_generation.py -v
```

#### 4. Config validation —Ç–µ—Å—Ç—ã
```bash
# tests/test_config_validation.py
pytest tests/test_config_validation.py -v
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –í—Å–µ unit —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç (coverage >80%)
‚úÖ Integration —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
‚úÖ E2E —Ç–µ—Å—Ç –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–æ–≤
‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
‚úÖ –ù–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –±–∞–≥–æ–≤

---

## ‚úÖ CHECKPOINT 1.4.8: –°–û–•–†–ê–ù–ï–ù–ò–ï –î–ê–ù–ù–´–• –î–õ–Ø –ë–≠–ö–¢–ï–°–¢–ê

### üì¶ Signal History Logger
```python
# signal_history_logger.py
import sqlite3
import json
from datetime import datetime
from pathlib import Path

class SignalHistoryLogger:
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞"""
    
    def __init__(self):
        self.db_path = './data/signal_history.db'
        self.json_dir = Path('./data/signal_history_json/')
        self.json_dir.mkdir(parents=True, exist_ok=True)
        self._init_database()
    
    def _init_database(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS signal_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER,
                asset TEXT,
                signal_type TEXT,
                confidence REAL,
                strength TEXT,
                spot_price REAL,
                config_hash TEXT,
                data_quality_status TEXT,
                data_quality_completeness REAL,
                reasoning TEXT,
                data_snapshot_json TEXT,
                strategies_json TEXT
            )
        ''')
        
        # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_timestamp ON signal_history(timestamp)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_asset ON signal_history(asset)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_config ON signal_history(config_hash)')
        
        conn.commit()
        conn.close()
    
    def log_signal(self, signal_result: Dict[str, Any]):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é —Å–∏–≥–Ω–∞–ª–∞"""
        
        try:
            signal = signal_result['signal']
            data_snapshot = signal_result['data_snapshot']
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO signal_history (
                    timestamp, asset, signal_type, confidence, strength,
                    spot_price, config_hash, data_quality_status,
                    data_quality_completeness, reasoning,
                    data_snapshot_json, strategies_json
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                int(datetime.now().timestamp()),
                signal_result['asset'],
                signal['signal_type'],
                signal['confidence'],
                signal['strength'],
                data_snapshot.get('spot_price'),
                signal.get('config_version'),
                data_snapshot.get('quality', {}).get('status'),
                data_snapshot.get('quality', {}).get('completeness'),
                json.dumps(signal.get('reasoning', [])),
                json.dumps(data_snapshot, default=str),
                json.dumps(signal_result.get('strategies', []), default=str)
            ))
            
            conn.commit()
            conn.close()
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º JSON –¥–ª—è ML (–±–æ–ª–µ–µ —É–¥–æ–±–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç)
            self._save_to_json(signal_result)
            
            logger.info(f"üìù Logged signal for {signal_result['asset']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error logging signal: {e}")
    
    def _save_to_json(self, signal_result: Dict[str, Any]):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ JSON –¥–ª—è ML –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            asset = signal_result['asset']
            filename = f"{asset}_signal_{timestamp}.json"
            filepath = self.json_dir / filename
            
            with open(filepath, 'w') as f:
                json.dump(signal_result, f, indent=2, default=str)
                
        except Exception as e:
            logger.error(f"Error saving JSON: {e}")
    
    def get_signals_by_config(self, config_hash: str, limit: int = 100):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM signal_history
            WHERE config_hash = ?
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (config_hash, limit))
        
        results = cursor.fetchall()
        conn.close()
        
        return results
    
    def get_performance_stats(self, config_hash: str):
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT 
                COUNT(*) as total_signals,
                AVG(confidence) as avg_confidence,
                COUNT(CASE WHEN strength = 'STRONG' THEN 1 END) as strong_signals,
                COUNT(CASE WHEN signal_type = 'BULLISH' THEN 1 END) as bullish_count,
                COUNT(CASE WHEN signal_type = 'BEARISH' THEN 1 END) as bearish_count
            FROM signal_history
            WHERE config_hash = ?
        ''', (config_hash,))
        
        result = cursor.fetchone()
        conn.close()
        
        return {
            'total_signals': result[0],
            'avg_confidence': result[1],
            'strong_signals': result[2],
            'bullish_count': result[3],
            'bearish_count': result[4]
        }
```

**–ö–†–ò–¢–ï–†–ò–ô –ó–ê–í–ï–†–®–ï–ù–ò–Ø:**
‚úÖ –ö–∞–∂–¥—ã–π —Å–∏–≥–Ω–∞–ª —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –ë–î
‚úÖ –ö–∞–∂–¥—ã–π —Å–∏–≥–Ω–∞–ª —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ JSON –¥–ª—è ML
‚úÖ –ú–æ–∂–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –º–æ–º–µ–Ω—Ç —Å–∏–≥–Ω–∞–ª–∞
‚úÖ –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ä–∞–±–æ—Ç–∞—é—Ç
‚úÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–Ω—Ñ–∏–≥–∞–º –¥–æ—Å—Ç—É–ø–Ω–∞

---

## üìã –ò–¢–û–ì–û–í–´–ô CHECKLIST STAGE 1.4

### –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø—É–Ω–∫—Ç—ã:
- [x] **1.4.1** - –ò–Ω–≤–µ–Ω—Ç–∞—Ä–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
- [x] **1.4.2** - DataIntegrator —Å–æ–∑–¥–∞–Ω –∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω
- [x] **1.4.3** - SignalAnalyzer —Å–æ–∑–¥–∞–Ω —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
- [x] **1.4.4** - –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã
- [ ] **1.4.5** - advanced_signals_generator –æ–±–Ω–æ–≤–ª–µ–Ω
- [x] **1.4.6** - HIGH PRIORITY –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã
- [x] **1.4.7** - –í—Å–µ –∫—Ä–∏—Ç–∏—á–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
- [x] **1.4.8** - –ò—Å—Ç–æ—Ä–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ):
- [ ] MEDIUM PRIORITY –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã
- [ ] LOW PRIORITY –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã
- [ ] –ü–æ–ª–Ω—ã–π test coverage (>80%)
- [ ] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤

---

## üéØ –°–õ–ï–î–£–Æ–©–ò–ô –≠–¢–ê–ü: STAGE 1.5 - BACKTESTING & ML OPTIMIZATION

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Stage 1.4 –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫:

### üîÑ Backtest Infrastructure
- –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
- –°–∏–º—É–ª—è—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏
- –†–∞—Å—á–µ—Ç –º–µ—Ç—Ä–∏–∫ (Sharpe, Win Rate, Profit Factor)

### ü§ñ ML Optimization
- –ë–∞–π–µ—Å–æ–≤—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
- Genetic algorithms –¥–ª—è –ø–æ–∏—Å–∫–∞ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö –≤–µ—Å–æ–≤
- Cross-validation –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –ø–µ—Ä–∏–æ–¥–∞—Ö

### üìä A/B Testing
- –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤
- –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä –ª—É—á—à–µ–π –º–æ–¥–µ–ª–∏

---

## üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–´–ï –ú–û–ú–ï–ù–¢–´

### 1. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**
- DataIntegrator –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å bottleneck (15+ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö)
- –†–µ—à–µ–Ω–∏–µ: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ asyncio
- –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö

### 2. **–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫**
- –í—Å–µ –¥–∞–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏
- –†–µ—à–µ–Ω–∏–µ: –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –≤ DataIntegrator –¥–ª—è –≤—Å–µ—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
- –ü—Ä–æ–≤–µ—Ä–∫–∞ max_age –≤ quality report

### 3. **–í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤**
- –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏ –±—ç–∫—Ç–µ—Å—Ç–æ–≤
- –†–µ—à–µ–Ω–∏–µ: Config hash –≤ –∫–∞–∂–¥–æ–º —Å–∏–≥–Ω–∞–ª–µ
- Git —Ç–µ–≥–∏ –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤

### 4. **–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π**
- –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
- –†–µ—à–µ–Ω–∏–µ: –î–µ—Ç–∞–ª—å–Ω—ã–π reasoning –≤ –∫–∞–∂–¥–æ–º —Å–∏–≥–Ω–∞–ª–µ
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ data snapshot

---

## üìà –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –†–ï–ê–õ–ò–ó–ê–¶–ò–ò

### ü•á –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: Core Infrastructure
1. DataIntegrator (1.4.2)
2. SignalAnalyzer (1.4.3)
3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ (1.4.5)

### ü•à –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: HIGH Priority –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
1. option_vwap_calculator.py
2. PCR RSI (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ)
3. GEX RSI (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ)

### ü•â –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 3: Testing & Logging
1. Unit —Ç–µ—Å—Ç—ã (1.4.7)
2. Signal History Logger (1.4.8)
3. Integration —Ç–µ—Å—Ç—ã

### üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 4: MEDIUM Priority –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
1. oi_macd_calculator.py
2. iv_macd_calculator.py

---

## üìä –ú–ï–¢–†–ò–ö–ò –£–°–ü–ï–•–ê STAGE 1.4

- ‚úÖ –í—Å–µ 15+ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Ä–∞–±–æ—Ç–∞—é—Ç –∏ —Å–æ–∑–¥–∞—é—Ç –≤—ã—Ö–æ–¥—ã
- ‚úÖ DataIntegrator —Å–æ–±–∏—Ä–∞–µ—Ç –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å quality report
- ‚úÖ SignalAnalyzer –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤–∞–ª–∏–¥–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
- ‚úÖ Confidence –≤—ã—à–µ min_confidence –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
- ‚úÖ –ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –ë–î –∏ JSON –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–∞
- ‚úÖ –°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ –Ω–∞ –≤—Å–µ—Ö 6 –∞–∫—Ç–∏–≤–∞—Ö
- ‚úÖ Data quality > ACCEPTABLE –¥–ª—è 80%+ –∑–∞–ø—É—Å–∫–æ–≤
- ‚úÖ –ú–æ–∂–Ω–æ A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥–∏

---

## üèÅ –ì–û–¢–û–í–ù–û–°–¢–¨ –ö STAGE 1.5

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö checkpoint'–æ–≤ Stage 1.4, —Å–∏—Å—Ç–µ–º–∞ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–∞ –∫:
- –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–æ–º—É –±—ç–∫—Ç–µ—Å—Ç—É
- ML –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤–µ—Å–æ–≤
- Production –∑–∞–ø—É—Å–∫—É —Å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏

**–ö—Ä–∏—Ç–µ—Ä–∏–π –ø–µ—Ä–µ—Ö–æ–¥–∞:** –í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø—É–Ω–∫—Ç—ã checklist –≤—ã–ø–æ–ª–Ω–µ–Ω—ã + 2 –Ω–µ–¥–µ–ª–∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã –≤ production.
